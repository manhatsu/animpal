import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenAI, Modality } from '@google/genai';

// APIキーを環境変数から取得
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// Geminiクライアントの初期化 (APIキーがなければエラー)
if (!GEMINI_API_KEY) {
  console.error('GEMINI_API_KEY is not set in environment variables.');
}

const ai = GEMINI_API_KEY ? new GoogleGenAI({ apiKey: GEMINI_API_KEY }) : null;

// 画像生成モデル
const generationModelName = 'gemini-2.0-flash-preview-image-generation';

export async function POST(req: NextRequest) {
  if (!ai) {
    console.error('Gemini AI client not initialized. API key missing.');
    return NextResponse.json({ 
      error: 'Gemini AI client not initialized', 
      details: 'API key is missing. Please check your .env.local file.' 
    }, { status: 500 });
  }

  try {
    const body = await req.json();
    const { text: userText, imageBase64 } = body;

    console.log('Received request for generateAvatarImage:', {
      hasText: !!userText,
      hasImage: !!imageBase64,
      textLength: userText?.length,
      imageLength: imageBase64?.length
    });

    if (!userText || !imageBase64) {
      console.error('Missing required parameters:', { userText: !!userText, imageBase64: !!imageBase64 });
      return NextResponse.json({ 
        error: 'Missing parameters', 
        details: 'Both text and imageBase64 are required in the request body' 
      }, { status: 400 });
    }

    const pureBase64Image = imageBase64.startsWith('data:')
      ? imageBase64.substring(imageBase64.indexOf(',') + 1)
      : imageBase64;

    console.log('Processing image data for Gemini:', {
      originalLength: imageBase64.length,
      processedLength: pureBase64Image.length,
      first10Chars: pureBase64Image.substring(0, 10)
    });

    try {

      const prompt = `画像に写っている犬のぬいぐるみの顔や表情は変えずに、入力のテキスト内容に最も合うように、このキャラクターを含む新しい画像を生成してください。生成する画像には文字を追加しないでください。\n\nテキスト: "${userText}"`;

      const contents = [
        { text: prompt },
        {
          inlineData: {
            mimeType: 'image/jpeg',
            data: pureBase64Image,
          },
        },
      ];

      console.log('Sending request to Gemini API with model:', generationModelName);
      console.log('Request prompt (first 100 chars):', prompt.substring(0, 100));
      const response = await ai.models.generateContent({
        model: generationModelName,
        contents: contents,
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        },
      });

      console.log('Received response from Gemini API');

      
      if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content || !response.candidates[0].content.parts) {
        console.error('Unexpected response format from Gemini:', JSON.stringify(response, null, 2));
        return NextResponse.json({ 
          error: 'Unexpected response format from Gemini', 
          details: 'The response from Gemini API was not in the expected format',
          gemini_response: JSON.stringify(response)
        }, { status: 500 });
      }
      
      const parts = response.candidates[0].content.parts;
      let generatedImageBase64: string | null = null;

      for (const part of parts) {
        if (part.inlineData && part.inlineData.data) {
          generatedImageBase64 = part.inlineData.data;
          console.log("Generated image data received from Gemini (first 100 chars):", generatedImageBase64.substring(0,100) + "...");
        }
      }
      
      let firstTextPart: string | null = null;
      for (const part of parts) { 
          if (part.text) {
              firstTextPart = part.text;
              console.log("Associated text from Gemini (first 100 chars):", firstTextPart.substring(0,100) + "...");
              break; 
          }
      }

      if (generatedImageBase64) {
        return NextResponse.json({ 
          imageUrl: `data:image/jpeg;base64,${generatedImageBase64}`
        });
      } else if (firstTextPart) {
        console.warn("Gemini did not return an image, but returned text:", firstTextPart);
        return NextResponse.json({ 
          error: 'No image generated by Gemini', 
          details: 'Gemini returned text instead of an image',
          generated_text: firstTextPart
        }, { status: 202 });
      } else {
        console.error('Gemini API did not return image data or usable text.');
        return NextResponse.json({ 
          error: 'No response data from Gemini', 
          details: 'Gemini API did not return any image data or usable text',
          gemini_response: JSON.stringify(response)
        }, { status: 500 });
      }
    } catch (modelError: any) { 
      console.error('Error in Gemini API call (modelError):', modelError);
      const errorMessage = modelError?.message || 'Unknown error in Gemini API call';
      const errorDetails = modelError?.response?.data || modelError?.toString(); 
      const errorStack = modelError?.stack;
      console.error('Error stack (modelError):', errorStack);
      return NextResponse.json({ 
        error: 'Gemini API processing error', 
        details: errorMessage,
        gemini_error_details: errorDetails,
        stack: errorStack,
        model: generationModelName
      }, { status: 500 });
    }

  } catch (error: any) { 
    console.error('Error in API route generateAvatarImage (outer try-catch):', error);
    const errorMessage = error?.message || 'An unknown error occurred in API route';
    const errorStack = error?.stack;
    console.error('Error stack (outer try-catch):', errorStack);
    return NextResponse.json({ 
      error: 'Internal Server Error in API route', 
      details: errorMessage,
      stack: errorStack
    }, { status: 500 });
  }
}